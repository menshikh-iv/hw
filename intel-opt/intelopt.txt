		=== vec_1 === 
		Написать программу вычисления скалярного произведения векторов
		Скомпилировать программу без оптимизации и замерить время выполнения
		Скомпилировать программу с оптимизацией -O2 и включенным отчетом о векторизации, замерить время выполнения
		Сравнить производительность векторизации для типов данных float и double
		(По желанию) Векторизовать программу с использованием gcc и сравнить производительность с icc

		=== vec_2 ===
		(3_Vektorizatsia.pdf)
		Какой тип данных будет векторизован?
		◦ Массив структур
		◦ Структура массиво
		- Написать программу, реализующую оба типа данных
		- Объяснить результаты


	    === par_1  === [run_5.sh]
	    Написать программу по перемножению матриц
	    Запустить программу с автоматическим распараллеливанием и без него, оценить разницу
	    Какие циклы удалось распараллелить? Как изменить порядок распараллеливания? “Правильно” ли компилятор распараллелил программу?

		=== par_2 ===
		Написать программу, определяющую количество всех простых числе в диапазоне от 0 до N. Запустить программу с автоматическим распараллеливанием и без него, оценить разницу и объяснить результат.


=== cyс_1 ===
Вынос условных переходов
Вынос инвариантных для циклов условных переходов путем дублирования тела цикла.
1. Измерить время исполнения «плохого» кода с ключом -Od.
2. Измерить время исполнения «плохого» кода с ключом -O3. Посмотреть отчет об оптимизациях.
3. Оптимизировать программу вручную. Используя -Od, постараться приблизить производительность к -O3.


=== cyc_2 ===
Перестановка циклов
Смена порядка итерационных переменных
1. Измерить время исполнения «плохого» кода с ключом -Od.
2. Измерить время исполнения «плохого» кода с ключом -O3. Посмотреть отчет об оптимизациях.
3. Оптимизировать программу вручную. Используя -Od, постараться приблизить производительность к -O3.



		=== omp_1 ===
		Ускорить выполнение цикла for в программе, вычисляющей покоординатную функцию от элементов массива a: a[i]=F(a[i]);

		=== omp_2 === [run_8.sh (P50)]
		Элементы массива a инициализируются 0, массива b[0]…b[n-1] – случайными числами от 0 до n-1. Распараллелить цикл 
		for (i=0; i<n; i++) a[b[i]]++;

		=== omp_3 ===
		Распараллелить цикл вычисления суммы
				for (i=0; i<n; i++) sum+=F(i);

		=== omp_4 === [run_10_alt.sh (P50)]
		Написать программу, вычисляющую количество простых чисел в диапазоне от 2 до N. Ускорить ее с помощью OpenMP. (я хз что там надо)



		=== int_1 === [123_int/1/run.sh] 
		Скомпилировать программу с межпроцедурными оптимизациями и без них.
		Проверить, остался ли вызов сторонней функции.
		Для генерации ассемблерного кода использовать ключи -S, -ipo-S

		=== int_2 ===
		Скомпилировать программу с межпроцедурными оптимизациями и без них.
		В обоих случаях использовать ключи -parallel и -std=c99
		Проверить, произошло ли автоматическое распараллеливание, и объяснить полученный результат.



=== mkl_1 === [123_int/2/run.sh] 
Сравнить производительность операции перемножения матриц для одинарной и двойной точности:
* Скомпилированной с помощью опций -O0, -O2, -O3
* Распараллеленной с помощью OpenMP
* Выполненной с помощью Intel MKL


=== PROJECT ===
ПРОЕКТ (Оптимизация MinHash)
